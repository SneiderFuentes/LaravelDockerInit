# docker-compose.yml
services:
    app: &app-base
        build:
            context: .
            dockerfile: docker/php/Dockerfile
        image: appointments_app
        container_name: appointments_app
        restart: unless-stopped
        working_dir: /var/www
        # inyectamos todo lo de .env en el contenedor
        env_file:
            - .env
        # montamos tu código
        volumes:
            - ./:/var/www
            - vendor-data:/var/www/vendor
        # Agregamos configuración para acceder al host
        extra_hosts:
            - "host.docker.internal:host-gateway"
        healthcheck:
            test: ["CMD-SHELL", "nc -z 127.0.0.1 9000 || exit 1"]
            interval: 20s
            timeout: 5s
            retries: 3
            start_period: 30s
        networks:
            - appnet
        depends_on:
            db:
                condition: service_healthy
            redis:
                condition: service_healthy
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"
        environment:
            - TZ=America/Bogota

    db:
        image: mysql:8.0
        container_name: appointments_db
        restart: unless-stopped
        healthcheck:
            test:
                [
                    "CMD-SHELL",
                    "mysqladmin ping -h 127.0.0.1 -u root -p$${MYSQL_ROOT_PASSWORD} || exit 1",
                ]
            interval: 30s
            timeout: 10s
            retries: 5
            start_period: 60s
        environment:
            MYSQL_ROOT_PASSWORD: secret
            MYSQL_DATABASE: appointments
            MYSQL_USER: appuser
            MYSQL_PASSWORD: apppass
            TZ: America/Bogota
        command: --default-authentication-plugin=mysql_native_password --tls-version=TLSv1.2 --mysqlx=0
        ports:
            - "3307:3306"
        volumes:
            - dbdata:/var/lib/mysql
            - ./docker/mysql/init:/docker-entrypoint-initdb.d
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"

    redis:
        image: redis:7-alpine
        container_name: appointments_redis
        restart: unless-stopped
        command: redis-server --appendonly yes
        healthcheck:
            test: ["CMD", "redis-cli", "ping"]
            interval: 10s
            timeout: 3s
            retries: 3
            start_period: 15s
        volumes:
            - redisdata:/data
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"
        environment:
            - TZ=America/Bogota

    nginx:
        image: nginx:stable-alpine
        container_name: appointments_nginx
        restart: unless-stopped
        healthcheck:
            test: ["CMD-SHELL", "curl -f http://127.0.0.1/health || exit 1"]
            interval: 15s
            timeout: 5s
            retries: 3
            start_period: 30s
        ports:
            - "80:80"
        volumes:
            - ./:/var/www
            - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
        depends_on:
            app:
                condition: service_healthy
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"
        environment:
            - TZ=America/Bogota

    horizon:
        <<: *app-base
        container_name: appointments_horizon
        restart: unless-stopped
        # inyectamos las mismas vars que en app
        env_file:
            - .env
        volumes:
            - ./:/var/www
            - vendor-data:/var/www/vendor
        # sobreescribimos solo el comando de arranque
        command: ["php", "artisan", "horizon"]
        healthcheck:
            test: ["CMD-SHELL", "php artisan horizon:status | grep -q running"]
            interval: 20s
            timeout: 5s
            retries: 3
            start_period: 30s
        # Agregamos configuración para acceder al host (heredado de app-base)
        depends_on:
            app:
                condition: service_healthy
            redis:
                condition: service_healthy
            db:
                condition: service_healthy
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"
        environment:
            - TZ=America/Bogota

    ngrok:
        image: ngrok/ngrok:latest # entrypoint = "ngrok"
        container_name: appointments_ngrok
        restart: unless-stopped
        healthcheck:
            test:
                [
                    "CMD-SHELL",
                    'wget -q -O - http://127.0.0.1:4040/api/tunnels | grep -q ''"tunnels"''',
                ]
            interval: 20s
            timeout: 5s
            retries: 3
            start_period: 45s
        depends_on:
            nginx:
                condition: service_healthy
        environment:
            NGROK_AUTHTOKEN: ${NGROK_AUTHTOKEN}
            TZ: America/Bogota
        # ⬇️ El comando se pasa SIN repetir la palabra 'ngrok'
        command:
            - "http" # sub-comando
            - "nginx:80" # <host interno>:<puerto>
            - "--hostname=app.colibrixa.com"
            - "--log=stdout" # para ver la URL con docker logs
        ports:
            - "4040:4040"
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"

    scheduler:
        <<: *app-base
        container_name: appointments_scheduler
        restart: unless-stopped
        command:
            [
                "sh",
                "-c",
                "while :; do php artisan schedule:run --verbose --no-interaction & sleep 60; done",
            ]
        healthcheck:
            test:
                ["CMD-SHELL", "ps aux | grep -v grep | grep -q 'schedule:run'"]
            interval: 30s
            timeout: 5s
            retries: 3
            start_period: 30s
        volumes:
            - ./:/var/www
            - vendor-data:/var/www/vendor
        environment:
            TG_BOT_TOKEN: ${TG_BOT_TOKEN:-}
            TG_CHAT_IDS: ${TG_CHAT_IDS:-}
            HEALTH_ALERT_THROTTLE_MINUTES: ${HEALTH_ALERT_THROTTLE_MINUTES:-30}
            TZ: America/Bogota
        depends_on:
            app:
                condition: service_healthy
            db:
                condition: service_healthy
            redis:
                condition: service_healthy
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"

    watcher:
        build: ./watcher
        container_name: appointments_watcher
        restart: unless-stopped
        environment:
            TG_BOT_TOKEN: ${TG_BOT_TOKEN:-}
            TG_CHAT_IDS: ${TG_CHAT_IDS:-}
            IGNORE_CONTAINERS: "appointments_watcher" # evita bucle
            VERBOSE: "0" # pon "1" si quieres alertas de healthy/start
            TZ: America/Bogota
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock:ro
        networks:
            - appnet
        logging:
            driver: "json-file"
            options:
                max-size: "10m"
                max-file: "7"

volumes:
    dbdata:
    redisdata:
    vendor-data:

networks:
    appnet:
